
_Note: Not all issues are guaranteed to be correct._

# Medium severity findings

## Improper Error Handling of onClaim Callback in _claim Function

### Targets
- _claim (Distributor)

### Description

The Distributor contract’s internal `_claim` function uses a try/catch to isolate failures in an external `onClaim` callback, but misplaces and asymmetrically handles reverts and invalid return values. As implemented, successful external calls that return an unexpected magic value trigger a revert inside the `try` block (uncaught), while genuine external call failures are silently swallowed in the empty `catch`. This leads to inconsistent and undesirable outcomes: a malformed or malicious recipient can either block the entire batch or bypass critical post-claim logic.

### Root cause

The `try/catch` surrounding the `IClaimRecipient.onClaim` callback is scoped only to the external call. Reverts or invalid returns detected inside the `try` success handler are not caught by the empty `catch`, and genuine external call failures are suppressed, resulting in both swallowed errors and uncaught reverts.

### Impact

1. A malicious or buggy `onClaim` implementation can return an incorrect value, triggering an uncaught `revert` that aborts the entire claim batch and undoes successful token transfers (DOS risk and user fund rollback).
2. Conversely, a reverting `onClaim` call is silently ignored, allowing recipients to bypass intended callback logic (e.g., audit hooks or state updates), undermining protocol invariants.

---

## Minimum Reward-Per-Hour Validation Applied to Gross Instead of Net Amount

### Targets
- _createCampaign (DistributionCreator)

### Description

The contract’s minimum reward-per-hour check is applied to the campaign’s gross amount before deducting protocol fees. After the check passes, fees are subtracted, reducing the net tokens distributed per hour below the required minimum. Because there is no re-validation after fee deduction, campaigns can appear compliant on-chain while actually underpaying recipients.

### Root cause

The code performs the minimum reward-per-hour validation against newCampaign.amount (gross) prior to computing and deducting fees. It never re-checks the threshold against the fee-adjusted (net) distribution amount.

### Impact

Campaign creators can deploy campaigns that meet the on-chain minimum rate check but pay out at a lower rate than advertised. This undermines participant incentives, violates expected protocol guarantees, and can deceive users into accepting lower rewards.


---

# Low severity findings

## Inconsistent Dispute State Management Enables Denial-of-Service and Dispute Window Bypass

### Targets
- getMerkleRoot (Distributor)
- setDisputeAmount (Distributor)
- resolveDispute (Distributor)
- updateTree (Distributor)
- resolveDispute/_revokeTree (Distributor)

### Description

Across multiple functions in the Distributor contract, the management of the dispute lifecycle—specifically the `disputer` flag and the `endOfDisputePeriod` timestamp—is flawed. These flaws allow malicious actors or even the governor to either block critical operations (like updating or rotating the Merkle root or enabling new claims) indefinitely or to bypass the intended dispute waiting period entirely.

### Root cause

Several code paths fail to correctly initialize, clear, or validate the on-chain dispute state:  
1. `disputer` is never reset automatically when the dispute period expires—only a manual governor call to `resolveDispute` can clear it (Refs 0 & 1).  
2. `setDisputeAmount` lacks a minimum validation, letting an attacker stake zero tokens and set `disputer` at no cost (Ref 1).  
3. The “valid” branch of `resolveDispute` omits updating `endOfDisputePeriod`, leaving a stale timestamp that permanently blocks non-governor `updateTree` calls (Ref 2).  
4. If `disputePeriod` is configured as zero and updates happen on epoch boundaries, the computed `endOfDisputePeriod` equals the current block time, allowing immediate back‐to‐back `updateTree` calls (Ref 4).  
5. The internal `_revokeTree` routine (invoked on valid dispute resolution) resets `endOfDisputePeriod` to zero unconditionally, closing the dispute window early and permitting instantaneous tree rotations (Ref 6).

### Impact

An attacker can initiate a free, indefinite dispute locking the distribution system—preventing all new claims or tree updates until governance intervenes. Conversely, authorized updaters or governors can completely bypass the dispute window to repeatedly and rapidly update the Merkle root without any challenge period, undermining the integrity and availability of the distribution mechanism.

---

## Missing Amount Field in campaignId Hash Leads to Identifier Collisions

### Targets
- campaignId (DistributionCreator)

### Description

The DistributionCreator’s campaignId function omits the critical `amount` field from its Keccak256 hash inputs. By only hashing chain ID, creator, reward token, campaign type, start timestamp, duration, and campaignData, two campaigns that differ solely by `amount` will produce identical IDs. This breaks the uniqueness guarantee of campaign identifiers.

### Root cause

The `campaignId` calculation fails to include the `amount` field from the CampaignParameters struct when computing the Keccak256 hash.

### Impact

Distinct campaigns differing only in their `amount` parameter can collide on the same ID, allowing an attacker (or even an honest user) to overwrite or block legitimate campaigns. This can lead to incorrect token distributions, state corruption, and denial-of-service on campaign creation.

---

## Deterministic Campaign ID Allows Front-Running and Griefing

### Targets
- campaignId (DistributionCreator)

### Description

The contract generates a campaign identifier by hashing only public, user-supplied fields (chain ID, creator, reward token, campaign type, start time, duration, and campaignData). Because no nonce or secret salt is included, an attacker can observe or predict the intended parameters and precompute the same ID. By submitting a conflicting campaign first, the attacker triggers a duplicate-ID revert in the legitimate user’s transaction, effectively griefing or blocking campaign creation.

### Root cause

Use of a purely deterministic ID derived from known parameters without any unpredictable salt or randomness.

### Impact

Attackers can front-run legitimate campaign creations, locking out users by preemptively creating a campaign with identical parameters. This prevents valid campaigns from ever being created or forces users to choose different parameters.

---

## Insufficient Merkle Root Retention Leads to Permanent Claim Lock

### Targets
- getMerkleRoot (Distributor)

### Description

The contract only stores two Merkle roots—the current distribution (`tree.merkleRoot`) and the immediate previous distribution (`lastTree.merkleRoot`). The `getMerkleRoot` function always returns one of these two roots based on dispute state, and the `claim` function relies solely on this return value to verify proofs. If the contract owner or operator updates the Merkle root more than twice before some users submit their claims, the root corresponding to earlier distributions is permanently overwritten. Those users lose access to the historical root needed to verify their Merkle proofs, effectively locking their allocations in the contract.

### Root cause

Only two Merkle trees (`tree` and `lastTree`) are kept in state, and there is no mechanism to archive or retrieve older distribution roots by identifier.

### Impact

Users who do not claim within the window of two subsequent updates will be unable to prove eligibility for earlier distributions, resulting in permanently locked tokens and potential financial loss.

---

## Missing Whitelist Enforcement in Reward Token Deposit and Withdrawal

### Targets
- increaseTokenBalance & decreaseTokenBalance (DistributionCreator)
- increaseTokenBalance (DistributionCreator)
- decreaseTokenBalance (DistributionCreator)

### Description

The DistributionCreator contract lacks enforcement of its reward token whitelist (rewardTokenMinAmounts) in both the deposit (increaseTokenBalance) and withdrawal (decreaseTokenBalance) paths. As a result, arbitrary ERC-20 tokens can be credited to user balances and withdrawn, bypassing governance-approved token controls.

### Root cause

Neither increaseTokenBalance (and its internal _updateBalance) nor decreaseTokenBalance (and its internal _updateBalance) validate that the provided rewardToken is whitelisted (i.e., has rewardTokenMinAmounts[rewardToken] > 0).

### Impact

Attackers or authorized users can deposit any ERC-20 token—approved or not—into the contract and later withdraw it, breaking governance controls over allowable reward tokens. This can lead to malicious or worthless tokens being tracked and distributed, loss of genuine assets, and disruption of reward calculations and entitlement mechanisms.

---

## Missing Whitelist Check in decreaseTokenAllowance Allows Stale Allowances

### Targets
- decreaseTokenAllowance (DistributionCreator)

### Description

The function decreaseTokenAllowance lets anyone with permission reduce allowances for any rewardToken without verifying that the token is currently whitelisted (i.e., has a non-zero minimum amount). After a token is removed from the whitelist by setting its minimum amount to zero, existing allowances remain in the creatorAllowance mapping and cannot be properly managed or cleared through normal protocol flows.

### Root cause

No whitelist validation is performed on the rewardToken parameter in either decreaseTokenAllowance or its internal call to _updateAllowance, allowing stale entries for unsupported tokens to persist.

### Impact

Stale allowances for tokens removed from the whitelist can accumulate indefinitely, leading to inconsistent accounting, possible denial of service in reward distribution or refund processes, and potential user confusion or loss of funds.

---

## All-or-Nothing Fee Recovery Revert

### Targets
- recoverFees (DistributionCreator)

### Description

The recoverFees function attempts to transfer balances of multiple ERC20 tokens from the contract to a recipient in a single loop. It uses SafeERC20.safeTransfer for each token but does not handle errors per-token. Because safeTransfer will revert on any transfer failure (either a revert or a false return), a failure on one token aborts the entire loop and reverts the transaction, preventing recovery of fees for all other tokens.

### Root cause

Use of SafeERC20.safeTransfer without per-token error handling (no try/catch) in a loop; a single failing token transfer will revert the entire recoverFees call.

### Impact

A malicious or misconfigured token that reverts or returns false on transfer can block fee recovery for all tokens. This could be used to lock all recoverable fees indefinitely, denying the governor or protocol from retrieving accumulated assets.

---

## Unrestricted and Immediate ERC20 Recovery Allows Governor to Drain Reserved Tokens

### Targets
- recoverERC20 (Distributor)

### Description

The Distributor contract’s `recoverERC20` function enables any account with GOVERNOR_ROLE to instantly transfer any ERC-20 token held by the contract—whether native distribution tokens, dispute tokens, or user-reserved balances—to an arbitrary address. There is no whitelist/blacklist to protect distribution or dispute tokens, no delays, and no multi-signature or timelock requirements. As a result, a compromised or malicious governor key can immediately drain all tokens earmarked for pending claims or dispute resolution.

### Root cause

The `recoverERC20` function performs an unchecked `safeTransfer` of any token balance solely based on the governor role, without validating the token against reserved allocations or imposing any governance guard (e.g., timelock, multi-signature, whitelist).

### Impact

A malicious or compromised governor can irreversibly withdraw tokens that back outstanding Merkle-tree distributions and dispute bonds, leading to immediate loss of user funds, permanent denial-of-service of claims/disputes, and complete undermining of the protocol’s integrity.

---

## Missing Validation on Governance Parameters Enables Denial-of-Service

### Targets
- setEpochDuration (Distributor)
- setDisputeAmount (Distributor)
- setDisputePeriod (Distributor)

### Description

Several governor-only setter functions in Distributor lack bounds or sanity checks, allowing a malicious or compromised governor to freeze core protocol operations. By supplying extreme or zero values to epochDuration, disputeAmount, and disputePeriod, the governor can indefinitely block distributions, dispute submissions, and dispute resolutions.

### Root cause

The contract’s configuration setters (setEpochDuration, setDisputeAmount, setDisputePeriod) perform no validation on their inputs. There are no upper or lower bounds, no non-zero requirements, and no sanity checks to ensure protocol liveness.

### Impact

A malicious or compromised governor can:  
• Set epochDuration to near uint32 max (≈136 years), preventing updateTree, resolveDispute, and revokeTree for decades.  
• Assign disputeAmount an excessively high value, causing safeTransferFrom/ safeTransfer to revert and disabling dispute operations.  
• Set disputeAmount to zero, allowing free disputes which can be spammed to block distribution updates.  
• Configure disputePeriod to zero or an unbounded value, disabling the dispute window or locking it open indefinitely.  
These actions lead to denial-of-service of distributions and dispute resolution, permanently halting protocol functionality.

---

## Governor can Drain User Campaign Funds via recoverFees

### Targets
- recoverFees (DistributionCreator)

### Description

The recoverFees function allows the governor to transfer the entire ERC-20 balance of any token held by the contract to an arbitrary address. Since campaign reward tokens and user-deposited tokens are stored in the same contract balances, and recoverFees makes no distinction between fee tokens and campaign funds, the governor can withdraw user funds intended for distribution campaigns.

### Root cause

recoverFees blindly loops over a user-supplied list of token addresses and invokes safeTransfer for the full contract balance of each, without consulting the contract’s whitelisted token mappings or distinguishing fee tokens from campaign tokens.

### Impact

A governor (or an attacker with governor privileges) can drain all user-deposited tokens and reward pools from the contract, causing loss of campaign funds and theft of user assets.

---

## Privileged Balance Inflation and Drain via increaseTokenBalance/decreaseTokenBalance

### Targets
- increaseTokenBalance (DistributionCreator)
- increaseTokenBalance / decreaseTokenBalance (DistributionCreator)

### Description

Multiple functions (`increaseTokenBalance` and `decreaseTokenBalance`) in DistributionCreator allow accounts with the governor role to manipulate internal token balances without corresponding on‐chain transfers, and then withdraw actual tokens. Specifically, governors can skip the guarded `safeTransferFrom` in `increaseTokenBalance`, credit arbitrary amounts to any user’s `creatorBalance`, and subsequently call `decreaseTokenBalance` to transfer real ERC-20 tokens out of the contract. This mismatch between internal accounting and real token custody lets a single compromised or malicious governor key mint “phantom” balances and drain the contract’s entire token reserves.

### Root cause

The logic in `increaseTokenBalance` conditions the token transfer on the caller not being a governor, but always updates the `creatorBalance` mapping. Meanwhile, `decreaseTokenBalance` allows governors to withdraw tokens from any user balance without additional checks. There is no enforcement that internal balances match actual deposited tokens, nor restriction preventing governors from arbitrarily crediting and debiting balances.

### Impact

A malicious or compromised governor can inflate any user’s balance by an arbitrary amount without depositing tokens and then withdraw real tokens from the contract up to the inflated total. This results in complete loss of ERC-20 funds held by the contract, undermining token custody guarantees and allowing theft of all assets.

---

## Unrestricted Governor Privileges Allow Wholesale Token Drain

### Targets
- decreaseTokenBalance (DistributionCreator)
- recoverFees (DistributionCreator)

### Description

Several functions in DistributionCreator grant the governor unilateral authority to withdraw ERC-20 tokens, bypassing internal accounting and user consent. The governor can both siphon user balances via decreaseTokenBalance and strip campaign reserves via recoverFees without any checks or updates to on-chain mappings. This flaw effectively breaks the custody guarantees of the contract and puts all tokens under protocol management at risk.

### Root cause

The governor role is granted excessive privileges in key token management functions. decreaseTokenBalance lets a governor reduce any user’s internal balance and transfer tokens out unilaterally, and recoverFees transfers full on-chain token balances without reconciling or validating against the creatorBalance mapping. Neither function restricts transactions to unallocated fees or enforces user permissions.

### Impact

A malicious or compromised governor key can drain all ERC-20 tokens held in DistributionCreator—both user reward balances and campaign-reserved funds—by calling decreaseTokenBalance for targeted accounts or recoverFees on any token. This results in complete loss of assets for users and creators, denial of service for ongoing campaigns, and a total breach of contract integrity.

---

## Unbounded User Fee Rebates Can Underflow and Deny Service

### Targets
- setUserFeeRebate (DistributionCreator)
- _computeFees (DistributionCreator)

### Description

The setUserFeeRebate function in DistributionCreator allows governors or guardians to assign arbitrary uint256 values to feeRebate[user] without any upper bound or sanity checks. Downstream, the internal _computeFees function calculates fees using BASE_9 - feeRebate[msg.sender]. If feeRebate exceeds BASE_9 (1e9), this subtraction underflows under Solidity 0.8’s checked arithmetic, causing a revert. Even setting feeRebate equal to BASE_9 results in a full fee discount. These unchecked rebate values can thus either inadvertently or maliciously block fee calculations, preventing users from creating or interacting with campaigns.

### Root cause

Lack of validation on the feeRebate parameter in setUserFeeRebate permits feeRebate[user] to exceed the BASE_9 denominator. No require statements enforce 0 ≤ feeRebate ≤ BASE_9.

### Impact

A malicious or misconfigured governor/guardian can set an excessive or exact-BASE_9 rebate for any user. If feeRebate > BASE_9, any call to _computeFees reverts, denying service in campaign creation and management functions (createCampaign, createCampaigns, etc.) for that user. If feeRebate == BASE_9, the user receives a 100% fee waiver, potentially bypassing protocol fee collection.

---

## Excessive Operator Privileges Enable Cross-Campaign Manipulation and Hijacking

### Targets
- _isValidOperator (DistributionCreator)
- toggleCampaignOperator (DistributionCreator)
- toggleCampaignOperator, overrideCampaign, reallocateCampaignRewards (DistributionCreator)
- reallocateCampaignRewards (DistributionCreator)

### Description

DistributionCreator’s operator system grants both governors and campaign managers overly broad and unsandboxed privileges, allowing attackers with valid operator rights—or governors themselves acting as operators—to manipulate or reallocate rewards across all campaigns without proper scoping, user consent, or validity checks.

### Root cause

The contract uses a single, two-dimensional mapping (manager → operator → bool) for all campaigns, omitting any campaign identifier. Additionally, the onlyUserOrGovernor modifier permits governors to toggle operator status on behalf of any user without user approval. Critical functions like overrideCampaign and reallocateCampaignRewards rely on _isValidOperator, which treats any approved operator as equally powerful for any campaign of the manager. There are no checks that operators are scoped per campaign, no verification of a user’s original participation, and no consent mechanism when governors assign operators.

### Impact

• A campaign operator approved for one campaign can invoke overrideCampaign or reallocateCampaignRewards on every campaign owned by the manager, altering parameters or siphoning unclaimed rewards across campaigns.
• A malicious governor can grant themselves or arbitrary addresses operator status on any user’s account, then hijack or sabotage campaigns by overriding settings or reallocating rewards to attacker-controlled addresses.
• Campaign owners and participants lose control and visibility over reward distributions, exposing them to theft of unclaimed tokens, unauthorized back-dating or premature expiration of campaigns, and complete campaign hijacking.

---

## Centralized Dispute Mechanism Allows Permanent Protocol Freeze

### Targets
- setDisputeAmount (Distributor)
- resolveDispute (Distributor)
- updateTree / revokeTree / getMerkleRoot (Distributor)
- updateTree / disputeTree (Distributor)

### Description

Multiple flaws in Distributor’s dispute module grant a single governor or malicious actor the ability to indefinitely block both configuration updates and Merkle‐tree operations, effectively halting distributions and dispute resolution with no automatic recovery.

### Root cause

Distributor centralizes control over the dispute workflow on a single `disputer` flag, a governor‐only `resolveDispute` action, and unguarded token recovery, without any timeouts, alternate clearing mechanisms, or balance checks. Specifically:
1. `disputer` is only reset via `resolveDispute`, so an unresolved or maliciously unresolved dispute permanently locks setters (`setDisputeAmount`) and tree updates (`updateTree`, `revokeTree`).
2. `recoverERC20` can drain the designated `disputeToken`, causing `resolveDispute` to revert on insufficient balance and leaving `disputer` uncleared.
3. `resolveDispute(false)` unconditionally recalculates and extends `endOfDisputePeriod`, allowing endless dispute rejections to push the window forward with no cap.
4. No auto-expiry or fallback exists; all clearing paths require a governor call, creating a single point of failure.

### Impact

A malicious or compromised governor (or an attacker controlling `accessControlManager`) can:
• Initiate a dispute and never resolve it, freezing all protocol configuration and tree updates.
• Drain the dispute token, making any future `resolveDispute` revert and locking `disputer` forever.
• Repeatedly reject disputes to extend the dispute window infinitely, blocking non-governor tree updates.
These actions cause a permanent denial-of-service for distributions, configuration changes, and dispute resolutions, with no recourse for users or off-chain governance.

---

## Multiple Merkle-Tree and Dispute Mechanism Flaws Enable Permanent Freezes and Bypass of Dispute Protections

### Targets
- _revokeTree (Distributor)
- updateTree (Distributor)
- updateTree and _revokeTree (Distributor)

### Description

The Distributor contract’s Merkle-tree update and dispute-resolution modules suffer from a series of interrelated bugs that allow a governor to freeze distributions indefinitely, disable revocation rollback, or bypass dispute windows entirely. These stem from missing validity checks on new and previous trees, improper initialization, and faulty dispute-period logic.

### Root cause

1. lastTree is never initialized before first use, so on the very first updateTree call it defaults to a zero‐value MerkleTree and can later be restored to a zero root.  
2. updateTree lacks checks that the new tree differs from the current one or that the provided Merkle root/IPFS hash is non-zero, allowing the same or invalid tree to be repeatedly submitted.  
3. _revokeTree unconditionally restores lastTree and resets endOfDisputePeriod to zero, violating invariants by decreasing or nullifying the dispute window.  
4. No guards exist to prevent endOfDisputePeriod from being lowered or equal to block.timestamp, enabling immediate re-updates after a revoke.

### Impact

• A governor can call revokeTree immediately after the first update to revert the active tree to the zero merkleRoot, breaking all subsequent claims and freezing distributions.  
• By re-submitting the same Merkle tree via updateTree, a malicious governor can indefinitely extend the dispute window, blocking non-governor tree updates or user claims forever.  
• After revoking, the dispute-window end is reset to zero, allowing the governor to immediately updateTree again—bypassing any intended dispute period—undermining dispute protections.  
• The combination of these flaws creates a permanent denial-of-service for distribution and dispute operations with no on-chain recovery path.

---

## Missing Validation on Dispute Token Configuration Leading to DoS or Exploitation

### Targets
- setDisputeToken (Distributor)

### Description

The Distributor contract’s governance setter `setDisputeToken` allows assigning any address—including the zero address or a non-ERC20/malicious contract—as the `disputeToken` without validation. Downstream dispute operations (e.g., `disputeTree`, `resolveDispute`) use `SafeERC20.safeTransfer` and `safeTransferFrom` on this token. If the token is set to address(0), these calls will revert, permanently disabling dispute creation and resolution. If set to a malicious or non-standard ERC20, arbitrary code execution or reentrancy may occur during transfers, potentially stealing funds or corrupting protocol state.

### Root cause

The `setDisputeToken` function lacks any checks on its input parameter. There is no validation to ensure the provided address is non-zero, nor that it implements a proper ERC20 interface. Consequently, an attacker with governor privileges can set a destructive or malicious token.

### Impact

A compromised or malicious governor can: 1) Set `disputeToken` to the zero address, causing every subsequent dispute operation to revert and permanently halting the dispute mechanism (denial-of-service). 2) Assign a malicious token contract to `disputeToken`, enabling arbitrary code execution (such as reentrancy or fund drainage) during safeTransfer calls, leading to theft or state corruption.

---

## Missing Input Validation on Address Parameters Enables State Corruption, DoS, and Token Loss

### Targets
- decreaseTokenAllowance (DistributionCreator)
- _updateBalance (DistributionCreator)
- reallocateCampaignRewards (DistributionCreator)
- setRewardTokenMinAmounts (DistributionCreator)
- recoverERC20 (Distributor)

### Description

Several functions across DistributionCreator and Distributor fail to validate critical address parameters, allowing zero-address or malicious inputs that corrupt internal mappings, cause denial-of-service, or irreversibly burn tokens. Attackers (or governors/authorized users) can exploit these gaps by supplying address(0) to poison allowance/balance tracking, burn tokens, disable campaigns, or disrupt distributions.

### Root cause

These functions lack require checks to ensure input addresses (user, operator, rewardToken, token, or beneficiary) are non-zero and, where applicable, valid ERC20 contracts. As a result, zero addresses slip through and are recorded in internal mappings or passed to SafeERC20 transfers without guard clauses.

### Impact

An attacker or malicious governor/authorized user can:
• Corrupt internal mappings under address(0), polluting creatorAllowance and creatorBalance entries (decreaseTokenAllowance, _updateBalance) and causing accounting errors or denial-of-service.
• Burn or lock tokens by setting recoverERC20 target to address(0), permanently destroying contract-held tokens.
• Disable campaign reward flows by whitelisting address(0) in rewardTokenMinAmounts, causing safeTransfer calls to revert and halting campaign creation/distribution.
• Silently burn or lock participants’ reallocated rewards by setting reallocateCampaignRewards ‘to’ address to zero, resulting in irrecoverable token loss when external distributors process the reallocation mapping.

---

## Allocation Underflow Denial of Service

### Targets
- _claim (Distributor)

### Description

If the contract’s owner or governor updates the Merkle root to a distribution where a user’s new allocated amount is lower than what they’ve already claimed, the subtraction `amount - claimed[user][token].amount` will underflow in Solidity ≥0.8.0 and automatically revert. This prevents the user from ever successfully claiming under the new distribution, effectively causing a denial of service for that user.

### Root cause

There is no check in `_claim` or in the Merkle‐root update functions to ensure that a newly published allocation (`amount`) is at least as large as the user’s previously recorded `claimed[user][token].amount`. The contract also never resets or adjusts `claimed[user][token]` when updating distributions.

### Impact

A malicious or misconfigured distribution update can freeze valid users out of their token claims. By publishing a tree with reduced allocations, an attacker (or governance) can permanently block claim executions for targeted users, denying them token disbursements.

---

## Overly Broad Guardian Permissions for ERC20 Operator Status

### Targets
- toggleMainOperatorStatus (Distributor)

### Description

The toggleMainOperatorStatus function differentiates access control by token: for native token actions (token==address(0)), only Governors can call; for ERC20 tokens (token!=address(0)), both Governors and Guardians can call due to the use of _onlyGuardian. Guardians can therefore arbitrarily grant or revoke main operator status on any ERC20 token. Main operators are permitted to invoke claim or claimWithRecipient on behalf of any user, potentially allowing Guardians to empower themselves or others to drain or misappropriate ERC20 token distributions.

### Root cause

The access control logic erroneously uses the _onlyGuardian (GovernorOrGuardian) check for non-native tokens instead of restricting ERC20 operator toggles to Governors only.

### Impact

A malicious or compromised Guardian can assign main operator status on ERC20 tokens, enabling forced claims from any user and unauthorized token siphoning or denial of service for rightful claimants.

---

## Insufficient Validation in overrideCampaign Allows Campaign Backdating and Premature Expiry

### Targets
- overrideCampaign (DistributionCreator)

### Description

The overrideCampaign function in DistributionCreator contains multiple validation flaws that permit authorized operators (including governors or campaign managers via operator status) to alter campaign timing in unintended ways. Specifically, operators can backdate a campaign so that it appears already expired upon override, or exploit an off-by-one error to modify start times exactly at campaign launch.

### Root cause

overrideCampaign’s guard logic fails to properly validate the relationship between the new startTimestamp, duration, and the current block time. Instead of checking newCampaign.startTimestamp + newCampaign.duration > block.timestamp, the code validates duration against the old start timestamp. Additionally, the comparison uses `>` rather than `>=`, allowing edge‐case bypass exactly at the start boundary.

### Impact

An attacker with operator privileges can:
• Backdate a campaign to already be expired by setting newCampaign.startTimestamp in the past combined with a duration that satisfies the flawed check against the old timestamp, blocking any future claims or participation effectively immediately.
• Exploit the off-by-one error at the moment a campaign begins (block.timestamp == oldStartTimestamp) to change its startTimestamp or other parameters without being prevented, enabling unexpected shifts in the reward window or unauthorized extensions.
These tactics can disrupt reward distribution, prevent users from claiming tokens, tamper with campaign schedules, and undermine the integrity of campaign data.

---

## Unchecked Reward Reallocation Pipeline Enables Phantom Transfers, Misallocation, and DoS

### Targets
- reallocateCampaignRewards (DistributionCreator)
- distributeCampaign (Distributor)

### Description

The reward reallocation workflow spanning DistributionCreator.reallocateCampaignRewards and Distributor.distributeCampaign lacks any validation of source addresses or entitlement. As a result, operators can insert arbitrary ‘from’ addresses (including non-participants) into the reallocation list, and the Distributor blindly processes each entry without verifying that the original address held claimable rewards. This flaw enables phantom transfers, misallocation of campaign tokens, zero-value operations that revert, and outright denial-of-service of distributions.

### Root cause

reallocateCampaignRewards does not confirm that each address in its ‘froms’ array corresponds to a genuine participant or holds any rewards, nor does it clear or deduplicate entries. Distributor.distributeCampaign then iterates over this untrusted list without entitlement checks, attempting safeTransfer for every item regardless of actual balances.

### Impact

• A malicious operator or governor can redirect campaign tokens from any arbitrary or non-participant address to an attacker-controlled recipient, resulting in theft of legitimate allocations or creation of phantom rewards. 
• Processing zero-balance entries can cause safeTransfer calls to revert, disrupting or halting the entire distribution execution for all participants. 
• Repeated abuse of the reallocation list can bloat its length, leading to high gas costs or transaction failures when Distributor.distributeCampaign iterates over an excessively large array, effectively causing a denial-of-service.

---

## Unbounded campaignListReallocation Growth and Gas Exhaustion DoS

### Targets
- reallocateCampaignRewards (DistributionCreator)
- reallocateCampaignRewards / getCampaignListReallocation (DistributionCreator)

### Description

The DistributionCreator contract’s campaignListReallocation mapping accumulates entries without bounds, reset, or deduplication. Each call to reallocateCampaignRewards appends every element of the input `froms` array to campaignListReallocation[_campaignId] regardless of size or duplication. As a result, both the reallocation operation and any subsequent reads via getCampaignListReallocation increasingly consume more gas and storage, eventually leading to out‐of‐gas reverts or prohibitive storage bloat.

### Root cause

Missing input validation on the `froms` array size combined with no mechanism to cap, clear, or deduplicate entries in the dynamic campaignListReallocation array.

### Impact

An authorized operator or malicious actor can supply an arbitrarily large or repeatedly overlapping `froms` list to: 1) exhaust gas during reallocateCampaignRewards or when reading the list via getCampaignListReallocation, causing a denial of service; 2) indefinitely inflate contract storage costs, potentially locking functionality and increasing operational expenses.

---

## Missing Whitelist Enforcement in _updateBalance

### Targets
- _updateBalance (DistributionCreator)

### Description

The internal function `_updateBalance` directly updates the `creatorBalance` mapping for any given ERC20 token without verifying that the token is approved by the contract’s whitelist. Its callers—`increaseTokenBalance` and `decreaseTokenBalance`—also omit any whitelist checks. This allows users to record balances for arbitrary or malicious tokens, bypassing governance-controlled token approval.

### Root cause

Blind trust that upstream callers have already performed whitelist validation, with no enforcement of the whitelist inside `_updateBalance` itself.

### Impact

Users can deposit untrusted or malicious tokens into the system, corrupting reward distributions, enabling denial-of-service on distribution logic, and potentially tricking other users or downstream contracts into accepting or transferring unsupported tokens.

---

## Integer Division Rounds Small Distributions to Zero Fees

### Targets
- _computeFees (DistributionCreator)

### Description

When a non-zero fee rate is applied to very small distributionAmount values, the calculation (distributionAmount * (BASE_9 - fees)) / BASE_9 rounds down to zero. As a result, distributionAmountMinusFees becomes zero, and in the subsequent _pullTokens call the entire distributionAmount is taken as fees and sent to the feeRecipient. Users attempting to distribute small amounts inadvertently forfeit their entire distribution.

### Root cause

Integer division by the large BASE_9 denominator without a safeguard or minimum check allows non-zero fees on small amounts to truncate the net distribution to zero.

### Impact

Any distribution smaller than BASE_9/(BASE_9 - fees) will be completely consumed by fees, causing users to lose their entire token amount. This can lead to unexpected loss of funds for small distributions and potential denial of service for micro-distributions.

---

## Stale Reallocation Accumulation

### Targets
- reallocateCampaignRewards (DistributionCreator)

### Description

The function reallocateCampaignRewards can be called multiple times for the same campaignId without clearing or resetting the state variables campaignReallocation and campaignListReallocation. Each invocation appends new “from” addresses to the list and overwrites mapping entries, but never removes prior entries. Over time, stale and duplicate entries accumulate, leading to unintended redirections or misleading on-chain enumeration of reallocations.

### Root cause

There is no cleanup logic or single-use enforcement for the reallocation state variables; repeated calls simply append and overwrite without resetting.

### Impact

Accumulated stale entries can cause unintended reward redirections, skewed enumeration of reallocated addresses, and potential confusion or misuse by downstream logic that relies on these mappings and arrays.

---

## Global Operator Scoping Flaw in DistributionCreator

### Targets
- overrideCampaign / reallocateCampaignRewards (DistributionCreator)

### Description

The campaignOperators mapping tracks operator permissions per creator address without including a campaignId. As a result, once a creator grants operator rights via toggleCampaignOperator, that operator can invoke overrideCampaign or reallocateCampaignRewards on any campaign owned by that creator, not just the intended one.

### Root cause

campaignOperators is defined as mapping(address => mapping(address => uint256)) keyed only by creator and operator, omitting campaignId and thus scoping operator permissions globally per creator.

### Impact

An operator granted rights for one campaign can maliciously override campaign parameters or reallocate rewards on any campaign of the creator, enabling unauthorized fund diversion or configuration changes across all campaigns.

---

## Improper Use of tx.origin in Access Control

### Targets
- _claim (Distributor)

### Description

The _claim function authorizes claim execution by checking if msg.sender or tx.origin matches the user, or if the caller is an approved operator/mainOperator/governor or guardian. Relying on tx.origin is an anti-pattern: it breaks composability for contract-based wallets (which have msg.sender as a contract and tx.origin as the EOA) and enables phishing-style intermediary attacks where a malicious contract can invoke _claim for an EOA user without being an approved operator.

### Root cause

Using tx.origin for access control alongside msg.sender rather than relying solely on msg.sender-based operator checks.

### Impact

1. Contract-based wallets cannot call _claim unless explicitly whitelisted as operators, leading to poor composability and UX issues.
2. Attackers can craft intermediary contracts that call _claim on behalf of unsuspecting EOA users, potentially causing unexpected token distribution or misdirection via onClaim callbacks.

---

## Default Zero Signature Bypass in DistributionCreator

### Targets
- createCampaign (DistributionCreator)

### Description

Before any message is initialized via setMessage, messageHash defaults to zero and userSignatures entries default to zero. The hasSigned modifier used by createCampaign only checks that userSignatures[msg.sender] equals messageHash (among other zero checks), which succeeds (0 == 0) for all users. As a result, anyone can call createCampaign (or deposit functions) without ever calling acceptConditions or agreeing to the intended terms.

### Root cause

Reliance on default zero values for both messageHash and userSignatures and no requirement that messageHash be nonzero or initialized before enforcing the signature check.

### Impact

Attackers can create campaigns or deposit tokens without accepting terms or conditions, potentially leading to unauthorized campaigns, invalid token distributions, and compliance or legal risks.

---

## Fee Rebate Misattribution due to msg.sender-based Lookup

### Targets
- _computeFees (DistributionCreator)
- _createCampaign (DistributionCreator)

### Description

The DistributionCreator contract’s fee calculation logic relies on msg.sender to determine the rebate percentage, but msg.sender may be an operator or delegate rather than the actual campaign creator. As a result, the wrong rebate rate can be applied when creating campaigns, allowing operators to pay reduced fees on behalf of other users or to capture rebates incorrectly.

### Root cause

Both _computeFees (invoked by createCampaign(s)) and _createCampaign functions look up feeRebate[msg.sender] instead of using the true campaign creator’s address. The rebate is calculated prior to assigning or passing the actual creator’s address, so delegated callers inherit their own rebate status.

### Impact

Operators or delegated callers can exploit this to underpay fees or receive rebates they are not entitled to, diverting protocol revenues, enabling unfair fee discounts, and potentially causing financial losses and accounting inconsistencies.